# 第4章 类和接口

**类和接口是Java程序设计语言的核心，它们也是Java语言的基本抽象单元**。

初学Java的时候感觉类和接口都好简单，后续慢慢发现类和接口的设计并非是想象总的那么简单的，还有好多需要学习。

而这一章作者就阐述了一些指导原则，指导我们设计出更加有用、健壮和灵活的类和接口，很有意义。  

## 第13条 使类和成员的可访问性最小化

设计良好的模块对外部而言总是**隐藏了所有的细节**  

模块之间中通过它们的API进行通信，**一个模块不需要知道其他模块的内部工作情况**，这个概念被称为**信息隐藏**或**封装**，是*软件设计的基本原则之一*（还是封装好听啊，信息隐藏好low啊）  


封装可以**有效解除各个模块之间的耦合关系**，是现在模块化开发的基础，使模块**可以独立地开发、测试、优化、使用、理解和修改**。      


### 尽可能地使没各类或者成员不被外界访问。  

Java中可以通过**包**、**访问修饰符**（private protected public）控制类、接口和成员的`可访问性（accessibility）`  

除了应该暴露的API之外，我们应该尽可能少的开放访问权。  
因为一旦暴露给外界，可能会有风险，另外还需要保证一直维护与兼容。  

可以想象一下，当我们使用一个第三方库的时候，如果它暴露了一个不该暴露的类（假设为BitmapUtil），而我们恰好用了它里面的方法，结果它一升级，把方法改了，或者把方法去掉了，那我们不是懵了？  


所以不要去暴露那些不该暴露的类、接口、成员

### 小结
作者在最后给了小结，**应该始终尽可能地降低可访问性。应该防止把任何散乱的类、接口和成员变成API的一部分。除了公有静态final域的特殊情形之外，共有类都不应该包含公有域。并且要确保公有静态final域所引用的对象都不是可变的**  

## 第14条 在共有类中使用访问方法而非公有域


假设有一个类：  
```
public class Point{
	public double x;
	public double y;
}
```

作者的意思是不应该直接暴露`x y`,要为它们提供`getter`、`setter`方法，这样有利于添加约束条件，辅助行为。    

本人表示道理我懂，但是现在一般的类都不愿意去写getter setter了，真心觉得好烦啊，虽然方法可以用AS自动生成，我还是不太愿意去写，直接public就是那么任性      

## 第15条 使可变性最小化

> *不可变类：实例不能被修改的类*。**每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变**。如：String、基本类型的包装类、BigInteger和BigDecimal  
> 不可变类比可变类更加易于设计、实现和使用。它们不容易出错，且更加安全。  

不可变类的五条规则：
1. 不要提供任何会修改对象状态的方法。   
2. 保证类不会被扩展。 一般用final修饰  
3. 使所有的域都是final的。  
4. 使所有的域都成为私有的。（降低访问权限）  
5. 确保对于任何可变组件的互斥访问。（什么意思呢？）  

### 不可变类的优缺点

#### 线程安全
不要求同步，无惧多线程并发访问  

#### 不可变对象可以被自由地共享  
所以不需要保护性拷贝（如String类的拷贝构造器）
也可以重复利用，如:Boolean.FALSE/TRUE  
#### 不可变对象为其他对象提供了大量的构建（building blocks）
不是很懂  
#### 唯一的缺点：对于每个不同的值都需要一个单独的对象

如FALSE TRUE ，不过如果值少，到也没什么关系  
但是如String这样的不可变类，我们需要注意，多用StringBuilder（可变，性能好）  
### 小结

除非有很好的理由要让类成为可变的类，否则就应该是不可变的。  
如果类不能被做成是不可变的，仍然应该尽可能地限制它的可变性。（降低出错的可能性）  

## 第16条 复合优先于继承

在读HeadFirstDesignPattern的时候已经看到太多次了  

> 这里的继承是指 `实现继承`（implementation inheritance）也即`extends` 而不是`接口继承` 复合（composition）也应该是常听到的`组合`  


**继承打破了封装性** 子类依赖于超类中特定功能的实现细节  当超类发生改变，子类可能会遭到破坏  

比如随着版本的发布，超类需要新增方法，但是这些方法不是所有子类需要的，那么就破坏了子类！    

### 复合（组合）

复合，即使用包装类（wrapper class），其实这也就是设计模式中的`装饰者模式`   

另外值得一提的是，**复合以及转发并不是委托（delegation）**  

装饰者模式的优缺点不多说了，可以看设计模式的笔记  

### 小结
继承功能确实强大，但它也存在很多问题，比如违背了封装原则（是不是很矛盾？），对于两个类，它们确实有`is-a`的关系时候才使用继承！  

所以使用继承的时候要考虑清楚  


## 第17条 要么为继承而设计，并提供文档说明，要么就禁止继承

如标题，恩，我可是连注释都懒得写的人，怎么会写文档。。。

## 第18条 接口优于抽象类

## 第19条 接口只用于定义类型
## 第20条 类层次优于标签类

## 第21条 用函数对象表示策略

## 优先考虑静态成员类

## 本章小结